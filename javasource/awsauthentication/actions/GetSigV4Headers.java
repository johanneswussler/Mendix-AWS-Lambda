// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package awsauthentication.actions;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.MessageDigest;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.SimpleTimeZone;
import java.util.SortedMap;
import java.util.TreeMap;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.MendixRuntimeException;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;
import awsauthentication.impl.MxLogger;
import awsauthentication.proxies.CredentialsProvider;
import awsauthentication.proxies.SigV4Headers;
import awsauthentication.proxies.SigV4Parameter;

/**
 * GetSigV4Headers java action calculates and provides headers needed to make a RESTful call to AWS Services.
 * Description of all input entity attributes and the output entity attributes can be found in the attribute documentation in the Domain Model.
 * Note - If you are using session credentials (Credentials Provider is 'SESSION'), then add the header 'x-amz-security-token' with value as the session token in the REST request.
 */
public class GetSigV4Headers extends CustomJavaAction<IMendixObject>
{
	private IMendixObject __Credentials;
	private awsauthentication.proxies.Credentials Credentials;
	private IMendixObject __SigV4Builder;
	private awsauthentication.proxies.SigV4Builder SigV4Builder;
	private java.util.List<IMendixObject> __Headers;
	private java.util.List<awsauthentication.proxies.SigV4Parameter> Headers;
	private java.util.List<IMendixObject> __QueryParameters;
	private java.util.List<awsauthentication.proxies.SigV4Parameter> QueryParameters;

	public GetSigV4Headers(IContext context, IMendixObject Credentials, IMendixObject SigV4Builder, java.util.List<IMendixObject> Headers, java.util.List<IMendixObject> QueryParameters)
	{
		super(context);
		this.__Credentials = Credentials;
		this.__SigV4Builder = SigV4Builder;
		this.__Headers = Headers;
		this.__QueryParameters = QueryParameters;
	}

	@java.lang.Override
	public IMendixObject executeAction() throws Exception
	{
		this.Credentials = this.__Credentials == null ? null : awsauthentication.proxies.Credentials.initialize(getContext(), __Credentials);

		this.SigV4Builder = this.__SigV4Builder == null ? null : awsauthentication.proxies.SigV4Builder.initialize(getContext(), __SigV4Builder);

		this.Headers = java.util.Optional.ofNullable(this.__Headers)
			.orElse(java.util.Collections.emptyList())
			.stream()
			.map(__HeadersElement -> awsauthentication.proxies.SigV4Parameter.initialize(getContext(), __HeadersElement))
			.collect(java.util.stream.Collectors.toList());

		this.QueryParameters = java.util.Optional.ofNullable(this.__QueryParameters)
			.orElse(java.util.Collections.emptyList())
			.stream()
			.map(__QueryParametersElement -> awsauthentication.proxies.SigV4Parameter.initialize(getContext(), __QueryParametersElement))
			.collect(java.util.stream.Collectors.toList());

		// BEGIN USER CODE
		SimpleDateFormat dateTimeFormat = new SimpleDateFormat(datetimeFormat);
		dateTimeFormat.setTimeZone(new SimpleTimeZone(0, "UTC"));
		SimpleDateFormat dateStampFormat = new SimpleDateFormat(dateFormat);
		dateStampFormat.setTimeZone(new SimpleTimeZone(0, "UTC"));
		Date now = new Date();
		String amzDate = dateTimeFormat.format(now);
		String dateStamp = dateStampFormat.format(now);
		String endpoint = "";
		if(SigV4Builder.getURIPrefix()==null||SigV4Builder.getURIPrefix().isEmpty()||SigV4Builder.getURIPrefix().isBlank())
			endpoint = String.format("%s.%s.amazonaws.com", SigV4Builder.getServiceName(), SigV4Builder.getRegion());
		else
			endpoint = String.format("%s.%s.%s.amazonaws.com",SigV4Builder.getURIPrefix(), SigV4Builder.getServiceName(), SigV4Builder.getRegion());
		String payloadHash = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
		if(SigV4Builder.getRequestBody()!=null)
			payloadHash = !"UNSIGNED-PAYLOAD".equals(SigV4Builder.getRequestBody()) ? toHex(hash(SigV4Builder.getRequestBody())) : SigV4Builder.getRequestBody();

		Map<String, String> headers = new HashMap<String, String>();
		headers.put("host", endpoint);
		headers.put("x-amz-date", amzDate);
		headers.put("x-amz-content-sha256", payloadHash);
		

		if(Credentials.getProvider().equals(CredentialsProvider._SESSION)) {

			if (Credentials.getCredentials_SessionToken(getContext())!= null) {
				headers.put("x-amz-security-token", Credentials.getCredentials_SessionToken(getContext()).getToken());
			}
			else {
				throw new MendixRuntimeException("Credential Provider is set as 'SESSION' but value of session token is null");
			}
		}

		for (SigV4Parameter sigV4Header : Headers) {
			headers.put(sigV4Header.getKey(getContext()), sigV4Header.getValue(getContext()));
		}

		Map<String, String> queryParameters = new HashMap<String, String>();
		for (SigV4Parameter sigV4QueryParameter : QueryParameters) {
			queryParameters.put(sigV4QueryParameter.getKey(getContext()), sigV4QueryParameter.getValue(getContext()));
		}


		String canonicalUri = SigV4Builder.getPath();
		String canonicalQueryString = getCanonicalizedQueryString(queryParameters);
		String canonicalHeaders = getCanonicalizedHeaderString(headers);
		LOGGER.debug("The cannonical headers are "+canonicalHeaders);
		String signedHeaders = getCanonicalizeHeaderNames(headers);
		LOGGER.debug("The signed headers are "+signedHeaders);
		String canonicalRequest = String.format("%s\n%s\n%s\n%s\n%s\n%s",
				SigV4Builder.getHTTPMethod(),
				canonicalUri,
				canonicalQueryString,
				canonicalHeaders,
				signedHeaders,
				payloadHash);
		LOGGER.debug("--------- Canonical request --------");
		LOGGER.debug(canonicalRequest);
		LOGGER.debug("------------------------------------");
		String credentialScope = String.format("%s/%s/%s/%s",
				dateStamp,
				SigV4Builder.getRegion(),
				SigV4Builder.getServiceName(),
				terminator);
		String stringToSign = String.format("%s-%s\n%s\n%s\n%s",
				scheme,
				algorithm,
				amzDate,
				credentialScope,
				toHex(hash(canonicalRequest)));
		LOGGER.debug("--------- String to sign -----------");
		LOGGER.debug(stringToSign);
		LOGGER.debug("------------------------------------");
		String signature = getSignature(scheme,
				Credentials.getSecretAccessKey(),
				dateStamp,
				SigV4Builder.getRegion(),
				SigV4Builder.getServiceName(),
				stringToSign);
		String authorizationHeader = String.format("%s-%s Credential=%s/%s, SignedHeaders=%s, Signature=%s",
				scheme,
				algorithm,
				Credentials.getAccessKeyId(),
				credentialScope,
				signedHeaders,
				signature);
		headers.put("Authorization", authorizationHeader);
		LOGGER.debug("--------- Request headers ---------");
		LOGGER.debug(headers);
		LOGGER.debug("-----------------------------------");
		IMendixObject responseObject = Core.instantiate(getContext(), "AWSAuthentication.SigV4Headers");
		SigV4Headers sigV4SignedHeaders = SigV4Headers.initialize(getContext(), responseObject);
		String url = "";
		if(SigV4Builder.getURIPrefix()==null||SigV4Builder.getURIPrefix().isEmpty()||SigV4Builder.getURIPrefix().isBlank())
			url = String.format("https://%s.%s.amazonaws.com", SigV4Builder.getServiceName(), SigV4Builder.getRegion());
		else
			url = String.format("https://%s.%s.%s.amazonaws.com",SigV4Builder.getURIPrefix(), SigV4Builder.getServiceName(), SigV4Builder.getRegion());
		if (canonicalUri != "/") {
			url += canonicalUri;
		}
		if (canonicalQueryString != "") {
			url += ("?" + canonicalQueryString);
		}
		sigV4SignedHeaders.setEndpointUrl(url);
		sigV4SignedHeaders.setHeader_Authorization(authorizationHeader);
		sigV4SignedHeaders.setHeader_X_Amz_Date(amzDate);
		sigV4SignedHeaders.setHeader_Host(endpoint);
		sigV4SignedHeaders.setHeader_X_Amz_Content_Sha256(payloadHash);
		return sigV4SignedHeaders.getMendixObject();
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "GetSigV4Headers";
	}

	// BEGIN EXTRA CODE
	private static final MxLogger LOGGER = new MxLogger(GetSigV4Headers.class);
	private static final String datetimeFormat = "yyyyMMdd'T'HHmmss'Z'";
	private static final String dateFormat = "yyyyMMdd";
	private static final String scheme = "AWS4";
	private static final String algorithm = "HMAC-SHA256";
	private static final String terminator = "aws4_request";

	private static String getCanonicalizedQueryString(Map<String, String> parameters) {
		if ( parameters == null || parameters.isEmpty() ) {
			return "";
		}
		SortedMap<String, String> sorted = new TreeMap<String, String>();
		Iterator<Map.Entry<String, String>> pairs = parameters.entrySet().iterator();
		while (pairs.hasNext()) {
			Map.Entry<String, String> pair = pairs.next();
			String key = pair.getKey();
			String value = pair.getValue();
			sorted.put(urlEncode(key, false), urlEncode(value, false));
		}
		StringBuilder builder = new StringBuilder();
		pairs = sorted.entrySet().iterator();
		while (pairs.hasNext()) {
			Map.Entry<String, String> pair = pairs.next();
			builder.append(pair.getKey());
			builder.append("=");
			builder.append(pair.getValue());
			if (pairs.hasNext()) {
				builder.append("&");
			}
		}
		return builder.toString();
	}

	private static String getCanonicalizeHeaderNames(Map<String, String> headers) {
		List<String> sortedHeaders = new ArrayList<String>();
		sortedHeaders.addAll(headers.keySet());
		Collections.sort(sortedHeaders, String.CASE_INSENSITIVE_ORDER);
		StringBuilder buffer = new StringBuilder();
		for (String header : sortedHeaders) {
			if (buffer.length() > 0) buffer.append(";");
			buffer.append(header.toLowerCase());
		}
		return buffer.toString();
	}

	private static String getCanonicalizedHeaderString(Map<String, String> headers) {
		if ( headers == null || headers.isEmpty() ) {
			return "";
		}
		List<String> sortedHeaders = new ArrayList<String>();
		sortedHeaders.addAll(headers.keySet());
		Collections.sort(sortedHeaders, String.CASE_INSENSITIVE_ORDER);
		StringBuilder buffer = new StringBuilder();
		for (String key : sortedHeaders) {
			buffer.append(key.toLowerCase().replaceAll("\\s+", " ") + ":" + headers.get(key).replaceAll("\\s+", " "));
			buffer.append("\n");
		}
		return buffer.toString();
	}

	private static byte[] hash(String text) {
		try {
			MessageDigest md = MessageDigest.getInstance("SHA-256");
			md.update(text.getBytes("UTF-8"));
			return md.digest();
		} catch (Exception e) {
			throw new RuntimeException("Unable to compute hash while signing request: " + e.getMessage(), e);
		}
	}

	private static byte[] sign(String stringData, byte[] key, String algorithm) {
		try {
			byte[] data = stringData.getBytes("UTF-8");
			Mac mac = Mac.getInstance(algorithm);
			mac.init(new SecretKeySpec(key, algorithm));
			return mac.doFinal(data);
		} catch (Exception e) {
			throw new RuntimeException("Unable to calculate a request signature: " + e.getMessage(), e);
		}
	}

	private static String getSignature(String scheme,
			String awsSecretKey,
			String dateStamp,
			String region,
			String service,
			String stringToSign) {
		byte[] kSecret = (scheme + awsSecretKey).getBytes();
		byte[] kDate = sign(dateStamp, kSecret, "HmacSHA256");
		byte[] kRegion = sign(region, kDate, "HmacSHA256");
		byte[] kService = sign(service, kRegion, "HmacSHA256");
		byte[] kSigning = sign(terminator, kService, "HmacSHA256");
		byte[] signature = sign(stringToSign, kSigning, "HmacSHA256");
		return toHex(signature);
	}

	private static String toHex(byte[] data) {
		StringBuilder sb = new StringBuilder(data.length * 2);
		for (int i = 0; i < data.length; i++) {
			String hex = Integer.toHexString(data[i]);
			if (hex.length() == 1) {
				sb.append("0");
			} else if (hex.length() == 8) {
				hex = hex.substring(6);
			}
			sb.append(hex);
		}
		return sb.toString().toLowerCase(Locale.getDefault());
	}

	private static String urlEncode(String url, boolean keepPathSlash) {
		String encoded;
		try {
			encoded = URLEncoder.encode(url, "UTF-8").replace("+", "%20");
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException("UTF-8 encoding is not supported.", e);
		}
		if ( keepPathSlash ) {
			encoded = encoded.replace("%2F", "/");
		}
		return encoded;
	}
	// END EXTRA CODE
}
